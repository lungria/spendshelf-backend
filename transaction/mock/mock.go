// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"sync"
	"time"

	transaction2 "github.com/lungria/spendshelf-backend/transaction"

	"github.com/lungria/spendshelf-backend/importer/mono"
)

// Ensure, that BankAPIMock does implement BankAPI.
// If this is not the case, regenerate this file with moq.
var _ transaction2.BankAPI = &BankAPIMock{}

// BankAPIMock is a mock implementation of BankAPI.
//
//     func TestSomethingThatUsesBankAPI(t *testing.T) {
//
//         // make and configure a mocked BankAPI
//         mockedBankAPI := &BankAPIMock{
//             GetTransactionsFunc: func(ctx context.Context, query mono.GetTransactionsQuery) ([]mono.Transaction, error) {
// 	               panic("mock out the GetTransactions method")
//             },
//         }
//
//         // use mockedBankAPI in code that requires BankAPI
//         // and then make assertions.
//
//     }
type BankAPIMock struct {
	// GetTransactionsFunc mocks the GetTransactions method.
	GetTransactionsFunc func(ctx context.Context, query mono.GetTransactionsQuery) ([]mono.Transaction, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetTransactions holds details about calls to the GetTransactions method.
		GetTransactions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Query is the query argument value.
			Query mono.GetTransactionsQuery
		}
	}
	lockGetTransactions sync.RWMutex
}

// GetTransactions calls GetTransactionsFunc.
func (mock *BankAPIMock) GetTransactions(ctx context.Context, query mono.GetTransactionsQuery) ([]mono.Transaction, error) {
	if mock.GetTransactionsFunc == nil {
		panic("BankAPIMock.GetTransactionsFunc: method is nil but BankAPI.GetTransactions was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Query mono.GetTransactionsQuery
	}{
		Ctx:   ctx,
		Query: query,
	}
	mock.lockGetTransactions.Lock()
	mock.calls.GetTransactions = append(mock.calls.GetTransactions, callInfo)
	mock.lockGetTransactions.Unlock()
	return mock.GetTransactionsFunc(ctx, query)
}

// GetTransactionsCalls gets all the calls that were made to GetTransactions.
// Check the length with:
//     len(mockedBankAPI.GetTransactionsCalls())
func (mock *BankAPIMock) GetTransactionsCalls() []struct {
	Ctx   context.Context
	Query mono.GetTransactionsQuery
} {
	var calls []struct {
		Ctx   context.Context
		Query mono.GetTransactionsQuery
	}
	mock.lockGetTransactions.RLock()
	calls = mock.calls.GetTransactions
	mock.lockGetTransactions.RUnlock()
	return calls
}

// Ensure, that StorageMock does implement Storage.
// If this is not the case, regenerate this file with moq.
var _ transaction2.Storage = &StorageMock{}

// StorageMock is a mock implementation of Storage.
//
//     func TestSomethingThatUsesStorage(t *testing.T) {
//
//         // make and configure a mocked Storage
//         mockedStorage := &StorageMock{
//             SaveFunc: func(ctx context.Context, transactions []storage.Transaction) error {
// 	               panic("mock out the Save method")
//             },
//         }
//
//         // use mockedStorage in code that requires Storage
//         // and then make assertions.
//
//     }
type StorageMock struct {
	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, transactions []transaction2.Transaction) error

	// calls tracks calls to the methods.
	calls struct {
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Transactions is the transactions argument value.
			Transactions []transaction2.Transaction
		}
	}
	lockSave sync.RWMutex
}

// Save calls SaveFunc.
func (mock *StorageMock) Save(ctx context.Context, transactions []transaction2.Transaction) error {
	if mock.SaveFunc == nil {
		panic("StorageMock.SaveFunc: method is nil but Storage.Save was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Transactions []transaction2.Transaction
	}{
		Ctx:          ctx,
		Transactions: transactions,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, transactions)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//     len(mockedStorage.SaveCalls())
func (mock *StorageMock) SaveCalls() []struct {
	Ctx          context.Context
	Transactions []transaction2.Transaction
} {
	var calls []struct {
		Ctx          context.Context
		Transactions []transaction2.Transaction
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Ensure, that ImportIntervalGeneratorMock does implement ImportIntervalGenerator.
// If this is not the case, regenerate this file with moq.
var _ transaction2.ImportIntervalGenerator = &ImportIntervalGeneratorMock{}

// ImportIntervalGeneratorMock is a mock implementation of ImportIntervalGenerator.
//
//     func TestSomethingThatUsesImportIntervalGenerator(t *testing.T) {
//
//         // make and configure a mocked ImportIntervalGenerator
//         mockedImportIntervalGenerator := &ImportIntervalGeneratorMock{
//             GetIntervalFunc: func(ctx context.Context, accountID string) (time.Time, time.Time, error) {
// 	               panic("mock out the GetInterval method")
//             },
//         }
//
//         // use mockedImportIntervalGenerator in code that requires ImportIntervalGenerator
//         // and then make assertions.
//
//     }
type ImportIntervalGeneratorMock struct {
	// GetIntervalFunc mocks the GetInterval method.
	GetIntervalFunc func(ctx context.Context, accountID string) (time.Time, time.Time, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetInterval holds details about calls to the GetInterval method.
		GetInterval []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AccountID is the accountID argument value.
			AccountID string
		}
	}
	lockGetInterval sync.RWMutex
}

// GetInterval calls GetIntervalFunc.
func (mock *ImportIntervalGeneratorMock) GetInterval(ctx context.Context, accountID string) (time.Time, time.Time, error) {
	if mock.GetIntervalFunc == nil {
		panic("ImportIntervalGeneratorMock.GetIntervalFunc: method is nil but ImportIntervalGenerator.GetInterval was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		AccountID string
	}{
		Ctx:       ctx,
		AccountID: accountID,
	}
	mock.lockGetInterval.Lock()
	mock.calls.GetInterval = append(mock.calls.GetInterval, callInfo)
	mock.lockGetInterval.Unlock()
	return mock.GetIntervalFunc(ctx, accountID)
}

// GetIntervalCalls gets all the calls that were made to GetInterval.
// Check the length with:
//     len(mockedImportIntervalGenerator.GetIntervalCalls())
func (mock *ImportIntervalGeneratorMock) GetIntervalCalls() []struct {
	Ctx       context.Context
	AccountID string
} {
	var calls []struct {
		Ctx       context.Context
		AccountID string
	}
	mock.lockGetInterval.RLock()
	calls = mock.calls.GetInterval
	mock.lockGetInterval.RUnlock()
	return calls
}
